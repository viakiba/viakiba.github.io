---
layout: post
title: ProtoBuf 使用分享(下)
categories: [ProtoBuf]
description: ProtoBuf 使用分享
keywords: ProtoBuf
---

相关资料

```html
代码地址:
    https://github.com/viakiba/viakiba/tree/master/proto_demo/prototest
资料来源:
    https://colobu.com/2019/10/03/protobuf-ultimate-tutorial-in-go/#%E6%9B%B4%E6%96%B0%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B
```

### 高级使用
#### 消息嵌套

```html
https://www.tizi365.com/archives/380.html
```

#### oneOf 

如果你有一组字段，同时最多允许这一组中的一个字段出现，就可以使用Oneof定义这一组字段。

因为proto3没有办法区分正常的值是否是设置了还是取得缺省值(比如int64类型字段，如果它的值是0，你无法判断数据是否包含这个字段，因为0几可能是数据中设置的值，也可能是这个字段的零值)
所以你可以通过Oneof取得这个功能，因为Oneof有判断字段是否设置的功能。

    syntax = "proto3";
    package abc;
    message OneofMessage {
        oneof testOneof {
            string name = 1;
            int64 value = 2;
        }
    }

#### 更新字段类型

* 不要改变已有字段的字段编号
* 把单一一个值改变成一个新的oneof类型的一个成员是安全和二进制兼容的。把一组字段变成一个新的oneof字段也是安全的，如果你确保这一组字段最多只会设置一个。把一个字段移动到一个已存在的oneof字段是不安全的


##### 新增字段

    当你增加一个新的字段的时候，老系统序列化后的数据依然可以被你的新的格式所解析，只不过你需要处理新加字段的缺省值。 老系统也能解析你信息的值，新加字段只不过被丢弃了

##### 修改字段类型

* int32, uint32, int64, uint64 和 bool类型都是兼容的
* sint32 和 sint64兼容，但是不和其它整数类型兼容
* string 和 bytes兼容，如果 bytes 是合法的UTF-8 bytes的话
* 嵌入类型和bytes兼容，如果bytes包含一个消息的编码版本的话
* fixed32和sfixed32, fixed64和sfixed64
* enum和int32, uint32, int64, uint64格式兼容
  
##### 删除字段

* 只要字段编号不会在更新的消息类型中再次使用，就可以删除字段。 您可能想要重命名该字段，例如添加前缀“Obsolete_”，或者保留字段编号，这样.proto的未来用户就不会意外地重复使用该编号。

#### any

Any字段允许你处理嵌套数据，并不需要它的proto定义。一个Any以bytes呈现序列化的消息，并且包含一个URL作为这个类型的唯一标识和元数据。
为了使用Any类型，你需要引入google/protobuf/any.proto。

    import "google/protobuf/any.proto";
    message ErrorStatus {
        string message = 1;
        repeated google.protobuf.Any details = 2;
    }


### 其他 

#### JSON 映射

ProtoBuf 可以进行 json 编码 ，映射参考：

    https://developers.google.com/protocol-buffers/docs/proto3#json

##### 添加依赖

     <dependency>
         <groupId>com.googlecode.protobuf-java-format</groupId>
         <artifactId>protobuf-java-format</artifactId>
         <version>1.2</version>
     </dependency>  

##### 代码实现

     // protobuf 转 json
     Message.Builder message = Message.newBuilder();
     String json = JsonFormat.printToString(message.build());
     // json 转 protobuf
     JsonFormat.merge(json, message);

#### Option

* java_package
    - 默认情况下将使用proto包(在.proto文件中使用“package”关键字指定)。 package 通常不会生成友好的Java包，因为package 指定生成的包不会以反向域名开始。 如果生成的不是Java代码，则此选项无效。
    - option java_package = "com.example.foo";
* java_multiple_files 
    - 使消息、枚举和服务在包级别定义，而不是在以.proto文件命名的外部类中定义。
    - option java_multiple_files = true;
* java_outer_classname
    - 要生成的Java类的类名(因此也就是文件名)。 如果在.proto文件中没有指定显式的java_outer_classname，将通过将.proto文件名转换为驼峰大小写(因此foo_bar.proto变为FooBar.java)来构造类名。 如果不生成Java代码，则此选项无效。
    - option java_outer_classname = "Ponycopter";
* deprecated 
...................... 还有很多 每个语言都有自己的 option


#### service

ProtoBuf 可以搭配 GRPC 使用,生成 GRPC 服务接口.

```code
service SearchService {
  rpc Search(SearchRequest) returns (SearchResponse);
}
```