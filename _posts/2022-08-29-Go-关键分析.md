---
layout: post
title: Golang
categories: [Golang]
description: Go-关键分析
keywords: Golang
tags: Golang
markmap: true
---

掌握golang，除了掌握基本语法，对于一下知识的理解与运用，是熟练使用golang做好业务的关键。

    感谢：https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/

```markmap

# KeyWords-Go 

## go 

### 启用协程

- go func(msg string) { 
    fmt.Println(msg)   
}("going")

### [协程池](https://github.com/bytedance/gopkg/tree/develop/util/gopool) 

- gopool.Go(
    func(){       
      /// do your job  
    }
  )

## error ，defer 与 recover

### error

- error 是go定义的接口，并未对其进行规范。

- errors.New()

- fmt.Errorf("")

- [Go2提案](https://go.googlesource.com/proposal/+/master/design/go2draft-error-values-overview.md)

    - 其中提到了几种 error 的规范方式。
    - if err == nil {} 判断

### [defer](https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/)

- defer 的实现是由编译器和运行时共同完成的

- 经常被用于关闭文件描述符、关闭数据库连接以及释放资源

- tx := db.Begin()
  defer tx.Rollback() 

#### 关键

- 作用域
    - 只会在当前函数和方法返回之前被调用
    - 先进后出 先声明的defer语句在后声明的之后执行。
- 预计算
    - defer关键字会立刻拷贝函数中引用的外部参数.
    - func main() {
        startedAt := time.Now()
        defer fmt.Println(time.Since(startedAt))
        
        time.Sleep(time.Second)
    }
    - $ go run main.go
    0s

    - func main() {
	startedAt := time.Now()
	defer func() { fmt.Println(time.Since(startedAt)) }()
	
	time.Sleep(time.Second)
}
    - go run main.go
      1s

    - 虽然调用 defer 关键字时也使用值传递，但是因为拷贝的是函数指针，所以 time.Since(startedAt) 会在 main 函数返回前调用并打印出符合预期的结果。

- 数据结构

- 执行机制
    - 中间代码生成阶段的 cmd/compile/internal/gc.state.stmt 会负责处理程序中的 defer，该函数会根据条件的不同，使用三种不同的机制处理该关键字

- 分配方式 （三种不同类型 defer 的设计与实现原理）
    - 堆分配 (最初方式，性能最差)

    - 栈分配 (1.13引入，性能替身百分之30)

    - 开放编码 (1.14引入，性能做好)
        - 有条件开启
        - 编译期间判断 defer 关键字、return 语句的个数确定是否开启开放编码优化
        - 如果函数中 defer 关键字的数量多于 8 个或者 defer 关键字处于 for 循环中，那么我们在这里都会禁用开放编码优化，使用上两节提到的方法处理 defer。

### panic 与 recover

- 与 recover 通常一起出现

- 调用 panic 后会立刻停止执行当前函数的剩余代码，并在**当前Goroutine** 中递归执行调用方的 defer；

- recover 可以中止 panic 造成的程序崩溃。它是一个只能在 defer 中发挥作用的函数，在其他作用域中调用不会发挥作用；

- func panic(v interface{})
  pannic("XXX 错误")

- defer func() {
        if err1 := recover(); err1 != nil {
            log.GameSystemLog().Error("err........", zap.Any("error", err1))
        }
    }()

## [channel](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/) 无锁管道


- 概述 ： channel是一个缓冲器，遵循先入先出的设计。
    - 先从 Channel 读取数据的 Goroutine 会先接收到数据；
    - 先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利；
- 异步与同步
    - channel的容量会使得其长度为0（同步管道），长度大于0（异步管道<未满的前提>）
    - 特殊：chan struct{} 类型的异步 Channel — struct{} 类型不占用内存空间，不需要实现缓冲区和直接发送（Handoff）的语义；
- ch <- i 发送数据
    - 直接发送
        - 当存在等待的接收者时，通过 runtime.send 直接将数据发送给阻塞的接收者；
        - 当缓冲区存在空余空间时，将发送的数据写入 Channel 的缓冲区；
        - 当不存在缓冲区或者缓冲区已满时，等待其他 Goroutine 从 Channel 接收数据；  
    - 阻塞发送
- 接收数据，i <- ch
  i, ok <- ch
    - 直接接收

    - 阻塞接收

- 关闭 channel

    - close(ch)

## select

- Go 语言的 select 与操作系统中的 select 比较相似

- 特点

    - 与switch结构类似，但是 case 参数不同，select的必是 channel的收发 .

    - select 能在 Channel 上进行非阻塞的收发操作；

    - select 在遇到多个 Channel 同时响应时，会随机执行一种情况；
- TODO

## for 与 range

## 并发

### Mutex

### RWMutex

### WaitGroup

### context

### once

### Cond 

```